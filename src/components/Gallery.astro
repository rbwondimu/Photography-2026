---
interface Props {
    category?: string;
    limit?: number;
    seamless?: boolean;
}

const { category = "All", limit, seamless = false } = Astro.props;
import type { ImageMetadata } from 'astro';
import { Image } from 'astro:assets';

// Load all images from the portfolio directory (recursively)
const allImages = import.meta.glob<{ default: ImageMetadata }>('/src/assets/portfolio/**/*.{jpeg,jpg,png,gif,JPEG,JPG,PNG,GIF}');

let images = Object.keys(allImages);

// Sort images by name (or date if we could extract it easily, but name is stable)
// Desired order might be reverse alphabetical to show newest "M" or "Z" files first? 
// Or just random? Let's stick to default sort for now.
images.sort();

// Keep About-only profile photo out of the portfolio gallery.
images = images.filter((path) => !path.endsWith('/profile.jpg'));

// Build a more visually balanced sequence by interleaving filename groups
// so similar shots are less likely to appear back-to-back.
const byNaturalName = (a: string, b: string) =>
    a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });

const numericRoll: string[] = [];
const uuidBatch: string[] = [];
const imgBatch: string[] = [];
const otherBatch: string[] = [];

for (const path of images) {
    const name = path.split('/').pop() || '';
    if (/^IMG_/i.test(name)) {
        imgBatch.push(path);
    } else if (/^[0-9A-F]{8}-[0-9A-F]{4}-/i.test(name)) {
        uuidBatch.push(path);
    } else if (/^[0-9]/.test(name)) {
        numericRoll.push(path);
    } else {
        otherBatch.push(path);
    }
}

numericRoll.sort(byNaturalName);
uuidBatch.sort(byNaturalName);
imgBatch.sort(byNaturalName);
otherBatch.sort(byNaturalName);

const balancedImages: string[] = [];
while (numericRoll.length || uuidBatch.length || imgBatch.length || otherBatch.length) {
    if (numericRoll.length) balancedImages.push(numericRoll.shift()!);
    if (uuidBatch.length) balancedImages.push(uuidBatch.shift()!);
    if (imgBatch.length) balancedImages.push(imgBatch.shift()!);
    if (uuidBatch.length) balancedImages.push(uuidBatch.shift()!);
    if (otherBatch.length) balancedImages.push(otherBatch.shift()!);
}

images = balancedImages;

const alternateWhiteBorderImages = async (orderedPaths: string[]) => {
    try {
        if (orderedPaths.length <= 2) {
            return orderedPaths;
        }

        const first = orderedPaths[0];
        const last = orderedPaths[orderedPaths.length - 1];
        const middlePaths = orderedPaths.slice(1, -1);

        const sharpModule = await import('sharp');
        const sharp = sharpModule.default;

        const hasWhiteBorder = async (imgPath: string) => {
            const fullPath = `${process.cwd()}${imgPath}`;
            const { data, info } = await sharp(fullPath)
                .greyscale()
                .resize(48, 48, { fit: 'fill' })
                .raw()
                .toBuffer({ resolveWithObject: true });

            const width = info.width;
            const height = info.height;

            let borderSum = 0;
            let borderCount = 0;
            for (let x = 0; x < width; x++) {
                borderSum += data[x];
                borderCount++;
                borderSum += data[(height - 1) * width + x];
                borderCount++;
            }
            for (let y = 1; y < height - 1; y++) {
                borderSum += data[y * width];
                borderCount++;
                borderSum += data[y * width + (width - 1)];
                borderCount++;
            }

            let centerSum = 0;
            let centerCount = 0;
            const start = Math.floor(width * 0.25);
            const end = Math.ceil(width * 0.75);
            for (let y = start; y < end; y++) {
                for (let x = start; x < end; x++) {
                    centerSum += data[y * width + x];
                    centerCount++;
                }
            }

            const borderAvg = borderSum / borderCount;
            const centerAvg = centerSum / Math.max(centerCount, 1);
            return borderAvg > 235 && borderAvg - centerAvg > 20;
        };

        const withBorder: string[] = [];
        const withoutBorder: string[] = [];

        for (const path of middlePaths) {
            if (await hasWhiteBorder(path)) {
                withBorder.push(path);
            } else {
                withoutBorder.push(path);
            }
        }

        const alternated: string[] = [];
        const useBorderFirst = withBorder.length > withoutBorder.length;

        while (withBorder.length || withoutBorder.length) {
            if (useBorderFirst) {
                if (withBorder.length) alternated.push(withBorder.shift()!);
                if (withoutBorder.length) alternated.push(withoutBorder.shift()!);
            } else {
                if (withoutBorder.length) alternated.push(withoutBorder.shift()!);
                if (withBorder.length) alternated.push(withBorder.shift()!);
            }
        }

        return [first, ...alternated, last];
    } catch {
        // If image analysis is unavailable, keep original ordering.
        return orderedPaths;
    }
};

if (seamless) {
    images = await alternateWhiteBorderImages(images);
}

// Requested manual tweak: make current 2nd image appear 1st.
if (!seamless && images.length > 1) {
    [images[0], images[1]] = [images[1], images[0]];
}

// Requested manual tweak: move current 5th image to the end.
if (!seamless && images.length > 4) {
    const fifth = images.splice(4, 1)[0];
    images.push(fifth);
}

// Requested Featured tweak: when showing 6 images, swap positions 5 and 6.
if (limit === 6 && images.length > 5) {
    [images[4], images[5]] = [images[5], images[4]];
}

// Apply limit
if (limit) {
    images = images.slice(0, limit);
}

// Map to useful objects
const loadedImages = await Promise.all(
    images.map(async (path) => {
        const image = await allImages[path]();
        // Extract filename as title
        const name = path.split('/').pop()?.split('.')[0] || 'Untitled';
        return {
            src: image.default,
            title: name.replace(/-/g, ' '),
            category: 'Portfolio'
        };
    })
);

// Fallback to placeholders if no images found
const usePlaceholders = loadedImages.length === 0;
const placeholderImages = Array.from({ length: 9 }).map((_, i) => ({
    id: i,
    title: `Portfolio Shot ${i + 1}`,
    color: `hsl(${Math.random() * 360}, 50%, 40%)`
}));
---

<div class:list={["gallery-grid", { seamless }]}>
    {!usePlaceholders && loadedImages.map((img) => (
        <div class="gallery-item">
            <Image src={img.src} alt={img.title} width={1200} height={1600} class="image-real" />
            {!seamless && (
                <div class="overlay">
                    <h3>{img.title}</h3>
                </div>
            )}
        </div>
    ))}

    {usePlaceholders && placeholderImages.map((img) => (
        <div class="gallery-item">
            <div class="image-placeholder" style={`background-color: ${img.color};`}></div>
            {!seamless && (
                <div class="overlay">
                    <h3>{img.title}</h3>
                    <p style="font-size: 0.8rem; opacity: 0.8;">(Placeholder)</p>
                </div>
            )}
        </div>
    ))}
</div>

<style>
    .gallery-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: var(--spacing-md);
        padding: var(--spacing-md) 0;
    }
    
    .gallery-grid.seamless {
        display: flex;
        flex-direction: column;
        gap: 0;
        padding: 0;
        align-items: center;
        scroll-snap-type: y mandatory;
    }

    .gallery-item {
        position: relative;
        overflow: hidden;
        /* aspect-ratio: 3/4;  Remove aspect ratio for seamless to allow natural height */
    }

    .gallery-grid:not(.seamless) .gallery-item {
        aspect-ratio: 3/4;
        cursor: pointer;
    }
    
    /* Allow natural height in seamless mode */
    .gallery-grid.seamless .gallery-item {
        width: min(94vw, 1280px);
        height: calc(100vh - 120px);
        min-height: 520px;
        max-height: 980px;
        padding: 2.2vmin;
        box-sizing: border-box;
        display: flex;
        align-items: center;
        justify-content: center;
        scroll-snap-align: start;
    }

    .image-placeholder, .image-real {
        width: 100%;
        height: 100%;
        display: block; /* Remove whitespace */
        transition: transform 0.5s ease;
        object-fit: cover;
        object-position: center;
    }
    
    .gallery-grid.seamless .image-real {
        width: 100%;
        height: 100%;
        object-fit: contain;
        object-position: center;
    }

    .gallery-grid.seamless .image-placeholder {
        width: 100%;
        height: 100%;
    }

    @media (max-width: 768px) {
        .gallery-grid.seamless {
            gap: 2px;
            padding: 0;
        }

        .gallery-grid.seamless .gallery-item {
            width: 100%;
            height: auto;
            min-height: 0;
            max-height: none;
            padding: 0 1.1vmin;
            display: block;
            line-height: 0;
        }

        .gallery-grid.seamless .image-real {
            width: 100%;
            height: auto;
            max-height: none;
            display: block;
        }
    }

    .gallery-grid:not(.seamless) .gallery-item:hover .image-placeholder,
    .gallery-grid:not(.seamless) .gallery-item:hover .image-real {
        transform: scale(1.05);
    }

    .overlay {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        padding: var(--spacing-md);
        background: linear-gradient(transparent, rgba(0,0,0,0.8));
        color: white;
        opacity: 0;
        transition: opacity 0.3s ease;
        display: flex;
        align-items: flex-end;
    }

    .gallery-item:hover .overlay {
        opacity: 1;
    }

    .overlay h3 {
        margin: 0;
        font-family: var(--font-sans);
        font-size: 1rem;
        font-weight: 300;
        letter-spacing: 0.1em;
        text-transform: uppercase;
    }
</style>
