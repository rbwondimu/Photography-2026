---
interface Props {
    category?: string;
    limit?: number;
    seamless?: boolean;
}

const { category = "All", limit, seamless = false } = Astro.props;
import type { ImageMetadata } from 'astro';
import { Image } from 'astro:assets';

// Load all images from the portfolio directory (recursively)
const allImages = import.meta.glob<{ default: ImageMetadata }>('/src/assets/portfolio/**/*.{jpeg,jpg,png,gif,JPEG,JPG,PNG,GIF}');

let images = Object.keys(allImages);

// Sort images by name (or date if we could extract it easily, but name is stable)
// Desired order might be reverse alphabetical to show newest "M" or "Z" files first? 
// Or just random? Let's stick to default sort for now.
images.sort();

// Keep About-only profile photo out of the portfolio gallery.
images = images.filter((path) => !path.endsWith('/profile.jpg'));

// Build a more visually balanced sequence by interleaving filename groups
// so similar shots are less likely to appear back-to-back.
const byNaturalName = (a: string, b: string) =>
    a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });

const numericRoll: string[] = [];
const uuidBatch: string[] = [];
const imgBatch: string[] = [];
const otherBatch: string[] = [];

for (const path of images) {
    const name = path.split('/').pop() || '';
    if (/^IMG_/i.test(name)) {
        imgBatch.push(path);
    } else if (/^[0-9A-F]{8}-[0-9A-F]{4}-/i.test(name)) {
        uuidBatch.push(path);
    } else if (/^[0-9]/.test(name)) {
        numericRoll.push(path);
    } else {
        otherBatch.push(path);
    }
}

numericRoll.sort(byNaturalName);
uuidBatch.sort(byNaturalName);
imgBatch.sort(byNaturalName);
otherBatch.sort(byNaturalName);

const balancedImages: string[] = [];
while (numericRoll.length || uuidBatch.length || imgBatch.length || otherBatch.length) {
    if (numericRoll.length) balancedImages.push(numericRoll.shift()!);
    if (uuidBatch.length) balancedImages.push(uuidBatch.shift()!);
    if (imgBatch.length) balancedImages.push(imgBatch.shift()!);
    if (uuidBatch.length) balancedImages.push(uuidBatch.shift()!);
    if (otherBatch.length) balancedImages.push(otherBatch.shift()!);
}

images = balancedImages;

// Apply limit
if (limit) {
    images = images.slice(0, limit);
}

// Map to useful objects
const loadedImages = await Promise.all(
    images.map(async (path) => {
        const image = await allImages[path]();
        // Extract filename as title
        const name = path.split('/').pop()?.split('.')[0] || 'Untitled';
        return {
            src: image.default,
            title: name.replace(/-/g, ' '),
            category: 'Portfolio'
        };
    })
);

// Fallback to placeholders if no images found
const usePlaceholders = loadedImages.length === 0;
const placeholderImages = Array.from({ length: 9 }).map((_, i) => ({
    id: i,
    title: `Portfolio Shot ${i + 1}`,
    color: `hsl(${Math.random() * 360}, 50%, 40%)`
}));
---

<div class:list={["gallery-grid", { seamless }]}>
    {!usePlaceholders && loadedImages.map((img) => (
        <div class="gallery-item">
            <Image src={img.src} alt={img.title} width={1200} height={1600} class="image-real" />
            {!seamless && (
                <div class="overlay">
                    <h3>{img.title}</h3>
                </div>
            )}
        </div>
    ))}

    {usePlaceholders && placeholderImages.map((img) => (
        <div class="gallery-item">
            <div class="image-placeholder" style={`background-color: ${img.color};`}></div>
            {!seamless && (
                <div class="overlay">
                    <h3>{img.title}</h3>
                    <p style="font-size: 0.8rem; opacity: 0.8;">(Placeholder)</p>
                </div>
            )}
        </div>
    ))}
</div>

<style>
    .gallery-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: var(--spacing-md);
        padding: var(--spacing-md) 0;
    }
    
    .gallery-grid.seamless {
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 8px 0;
    }

    .gallery-item {
        position: relative;
        overflow: hidden;
        /* aspect-ratio: 3/4;  Remove aspect ratio for seamless to allow natural height */
    }

    .gallery-grid:not(.seamless) .gallery-item {
        aspect-ratio: 3/4;
        cursor: pointer;
    }
    
    /* Allow natural height in seamless mode */
    .gallery-grid.seamless .gallery-item {
        width: 100%;
        height: auto;
    }

    .image-placeholder, .image-real {
        width: 100%;
        height: 100%;
        display: block; /* Remove whitespace */
        transition: transform 0.5s ease;
        object-fit: cover;
        object-position: center;
    }
    
    .gallery-grid.seamless .image-real {
        height: auto;
        object-fit: contain;
    }

    .gallery-grid:not(.seamless) .gallery-item:hover .image-placeholder,
    .gallery-grid:not(.seamless) .gallery-item:hover .image-real {
        transform: scale(1.05);
    }

    .overlay {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        padding: var(--spacing-md);
        background: linear-gradient(transparent, rgba(0,0,0,0.8));
        color: white;
        opacity: 0;
        transition: opacity 0.3s ease;
        display: flex;
        align-items: flex-end;
    }

    .gallery-item:hover .overlay {
        opacity: 1;
    }

    .overlay h3 {
        margin: 0;
        font-family: var(--font-sans);
        font-size: 1rem;
        font-weight: 300;
        letter-spacing: 0.1em;
        text-transform: uppercase;
    }
</style>
